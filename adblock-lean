#!/bin/sh /etc/rc.common
# shellcheck disable=SC3043,SC1091,SC3001,SC2018,SC2019,SC3020,SC3003,SC2181,SC2254,SC1090,SC3045

# adblock-lean - super simple and lightweight adblocking for OpenWrt

# Project homepage: https://github.com/lynxthecat/adblock-lean

# Authors: @Lynx and @Wizballs (OpenWrt forum)
# Contributors: @antonk; @dave14305 (OpenWrt forum)

# global exit codes:
# 0 - Success
# 1 - Error
# 254 - Failed to acquire lock

# special variables for luci have the prefix 'luci_'

# expects that the RPC script for luci UI is named specifically 'luci.adblock-lean'


LC_ALL=C
IFS='	 
'
default_IFS="${IFS}"

if [ -t 0 ]
then
	msgs_dest="/dev/tty"
else
	msgs_dest="/dev/null"
fi

PREFIX=/root/adblock-lean
abl_dir=/var/run/adblock-lean
abl_pid_dir=/tmp/adblock-lean
config_file="${PREFIX}/config"
update_log_file="/var/log/abl_update.log"
session_log_file="/var/log/abl_session.log"

export PATH=/usr/sbin:/usr/bin:/sbin:/bin
export HOME=/root

START=99
STOP=4

EXTRA_COMMANDS="status pause resume gen_stats gen_config print_log update"
EXTRA_HELP="	
adblock-lean custom commands:
	status		check dnsmasq and good line count of existing blocklist
	pause		pause adblock-lean
	resume		resume adblock-lean
	gen_stats	generate dnsmasq stats for system log
	gen_config	generate default config
	print_log	print most recent session log
	update		update adblock-lean to the latest version"


### UTILITY FUNCTIONS

# sets variables for colors
set_colors()
{
	set -- $(printf '\033[0;31m \033[0;32m \033[1;34m \033[1;33m \033[0;35m \033[0m')
	red="${1}" green="${2}" blue="${3}" yellow="${4}" purple="${5}" n_c="${6}"
}

get_file_size_human()
{
	bytes2human "$(du -b "$1" | awk '{print $1}')"
}

# converts unsigned integer to [xB|xKiB|xMiB|xGiB|xTiB]
# if result is not an integer, outputs up to 2 digits after decimal point
# 1 - int
bytes2human()
{
	local i=${1:-0} s=0 d=0 m=1024 fp='' S=''
	case "$i" in *[!0-9]*) reg_failure "bytes2human: Invalid unsigned integer '$i'."; return 1; esac
	for S in B KiB MiB GiB TiB
	do
		[ $((i > m && s < 4)) = 0 ] && break
		d=$i i=$((i/m)) s=$((s+1))
	done
	d=$((d % m * 100 / m))
	case $d in
		0) printf "%s %s\n" "$i" "$S"; return ;;
		[1-9]) fp="02" ;;
		*0) d=${d%0}; fp="01"
	esac
	printf "%s.%${fp}d %s\n" "$i" "$d" "$S"
}

int2human()
{
	case "$1" in *[!0-9]*) reg_failure "int2human: Invalid unsigned integer '$1'."; return 1; esac
	local in_num="$1" out_num=''

	# strip leading zeroes
	while :
	do
		case "$in_num" in
			0?*) in_num="${in_num#0}" ;;
			*) break
		esac
	done

	while :
	do
		case "$in_num" in 
			????*)
				out_num=",${in_num#"${in_num%???}"}${out_num}"
				in_num="${in_num%???}" ;;
			*) break
		esac
	done
	out_num="${in_num}${out_num}"

	echo "${out_num#,}"
}

get_uptime_ms()
{
	read -r uptime_ms _ < /proc/uptime
	printf "${uptime_ms%.*}${uptime_ms#*.}0"
}

get_elapsed_time_str()
{
	# To use, first set initial uptime: initial_uptime_ms=$(get_uptime_ms)
	# Then call this function to get elapsed time string at desired intervals, e.g.:
	# printf "Elapsed time: $(get_elapsed_time_str)\n"

	elapsed_time_s=$(( ($(get_uptime_ms)-${initial_uptime_ms:-$(get_uptime_ms)})/1000 ))
	printf '%dm:%ds' $((elapsed_time_s/60)) $((elapsed_time_s%60))
}

print_msg()
{
	printf '%s\n' "${1}" > "$msgs_dest"
}

log_msg()
{
	local msg='' msg_prefix='' _arg err_l=info color=

	for _arg in "$@"
	do
		case "${_arg}" in
			"-err") err_l=err color="${red}" msg_prefix="Error: " ;;
			"-warn") err_l=warn color="${yellow}" msg_prefix="Warning: " ;;
			-blue|-red|-green|-purple|-yellow) eval "color=\"\${${_arg#-}}\"" ;;
			'') ;;
			*) msg="${msg}${msg_prefix}${_arg} "
		esac
	done
	msg="${msg% }"

	print_msg "${color}${msg}${n_c}"
	logger -t adblock-lean -p user."${err_l}" "${msg}"
	write_log_file "${msg}" "${err_l}"
}

# 1 - msg
# 2 - err level
write_log_file()
{
	[ -n "${log_file}" ] && { printf '['; date +'%b %d %Y, %H:%M:%S' | tr -d '\n'; printf '] %s\n' "${2:-info}: ${1}"; } >> "${log_file}"
}

try_mv()
{
	[ -z "${1}" ] || [ -z "${2}" ] && { reg_failure "try_mv(): bad arguments."; return 1; }
	mv -f "${1}" "${2}" || { reg_failure "Failed to move '${1}' to '${2}'."; return 1; }
	:
}

# 0 - (optional) '-p'
# 1 - path
try_mkdir()
{
	local p=
	[ "${1}" = '-p' ] && { p='-p'; shift; }
	[ -d "${1}" ] && return 0
	mkdir ${p} "${1}" || { reg_failure "Failed to create directory '${1}'."; return 1; }
	:
}

try_gzip()
{
	gzip -f "${1}" || { rm -f "${1}.gz"; reg_failure "Failed to compress '${1}'."; return 1; }
}

try_gunzip()
{
	gunzip -f "${1}" || { rm -f "${1%.gz}"; reg_failure "Failed to extract '${1}'."; return 1; }
}

# asks the user to pick an option
# 1 - input in the format 'a|b|c'
# output via $REPLY
pick_opt()
{
	update_pid_action "Waiting for user input in console" || return 1
	while :
	do
		printf %s "$1: " 1>${msgs_dest}
		read -r REPLY
		case "$REPLY" in *[!A-Za-z0-9]*) printf '\n%s\n\n' "Please enter $1" 1>${msgs_dest}; continue; esac
		eval "case \"$REPLY\" in 
				$1) return 0 ;;
				*) printf '\n%s\n\n' \"Please enter $1\" 1>${msgs_dest}
			esac"
	done
}


### HELPER FUNCTIONS

print_def_config()
{
	cat <<-EOT
	# adblock-lean configuration options
	# config_format=v2
	#
	# values must be enclosed in double-quotes
	# comments must start at newline or inline after the closing double-quote

	# One or more dnsmasq blocklist urls separated by spaces
	blocklist_urls="https://mirror.ghproxy.com/https://raw.githubusercontent.com/hagezi/dns-blocklists/main/dnsmasq/pro.txt https://mirror.ghproxy.com/https://raw.githubusercontent.com/hagezi/dns-blocklists/main/dnsmasq/tif.mini.txt"

	# One or more allowlist urls separated by spaces
	allowlist_urls=""

	# Path to optional local allowlist/blocklist files in the form:
	# site1.com
	# site2.com
	local_allowlist_path="${PREFIX}/allowlist"
	local_blocklist_path="${PREFIX}/blocklist"

	# Mininum number of lines of any individual downloaded part
	min_blocklist_part_line_count="1"
	min_allowlist_part_line_count="1"
	# Maximum size of any individual downloaded blocklist part
	max_file_part_size_KB="20000"
	# Maximum total size of combined, processed blocklist
	max_blocklist_file_size_KB="30000"
	# Minimum number of good lines in final postprocessed blocklist
	min_good_line_count="100000"

	# compress final blocklist, intermediate blocklist parts and the backup blocklist to save memory - enable (1) or disable (0)
	use_compression="1"

	# restart dnsmasq if previous blocklist was extracted and before generation of
	# new blocklist thereby to free up memory during generaiton of new blocklist - enable (1) or disable (0)
	initial_dnsmasq_restart="0"

	# Maximum number of download retries
	max_download_retries="3"

	# List part failed action:
	# This option applies to blocklist/allowlist parts which failed to download or couldn't pass validation checks
	# SKIP - skip failed blocklist file part and continue blocklist generation
	# STOP - stop blocklist generation (and fall back to previous blocklist if available)
	list_part_failed_action="SKIP"

	# If a path to custom script is specified and that script defines functions 'report_success()' and 'report_failure()'',
	# one of these functions will be executed when adblock-lean completes the execution of some commands,
	# with the success or failure message passed in first argument
	# report_success() is only executed upon completion of the 'start' command
	# Recommended path is '/usr/libexec/abl_custom-script.sh' which the luci app has permission to access
	custom_script=""

	# Start delay in seconds when service is started from system boot
	boot_start_delay_s="120"

	EOT
}

# get config format from config file contents
# input via STDIN or ${1}
get_config_format()
{
	local conf_form_sed_expr='/^[ \t]*#[ \t]*config_format=v/{s/.*=v//;p;q;}'
	if [ -n "${1}" ]
	then
		sed -n "${conf_form_sed_expr}" "${1}"
	else
		sed -n "${conf_form_sed_expr}"
	fi
}

# validate config and assign to variables
#
# 1 - path to file
#
# return codes:
# 0 - Success
# 1 - Error
# 2 - Unexpected, missing or legacy-formatted (no double quotes) entries found
#
# sets ${missing_keys}, ${conf_fixes}
# and variables for luci:
# *_curr_config_format *_def_config_format *_unexp_keys *_unexp_entries *_missing_keys *_missing_entries *_legacy_entries *_bad_conf_format *_conf_fixes
parse_config()
{
	inval_e()
	{
		IFS="${default_IFS}"
		reg_failure "Invalid entry '$entry' in config."
	}

	add_conf_fix()
	{
		conf_fixes="${conf_fixes}${1}"$'\n'
	}

	# Following 2 functions are needed to minimize ugly hacks and tinkering inside eval
	# shellcheck disable=SC2317
	parse_entry()
	{
		val=${entry#"${key}="}

		# Following 'case' is a temporary solution to allow easy config migration - remove a few months from now (Aug 2024)
		case "${entry}" in
			"compress_blocklist="?" #"*|"initial_dnsmasq_restart="?" #"*)
				legacy_entries="${legacy_entries}${entry}"$'\n'
				test_keys="${test_keys%%"${key}|"*}${test_keys#*"${key}|"}"
				val=${val%% *}
				return 0
		esac

		case "${val}" in
			*\"*\"*\"*) inval_e; return 1 ;; # do not allow more than 2 double-quote marks
			\"*\"*)
				local tmp_val="${val##*\"}" # remove value enclosed in double-quotes
				case "${tmp_val%%\#*}" in # do not allow characters between 2nd double-quote and in-line comment
					'') ;;
					*[!\ ${tab}]*) inval_e; return 1
				esac
				;;
			*\"*\"*) inval_e; return 1 ;; # double quote mark must be the first character
			*\"*) inval_e; return 1 ;; # do not allow 1 double-quote mark
			*"#"*) inval_e; return 1 ;; # do not allow in-line comments without double-quote marks
			*) legacy_entries="${legacy_entries}${entry}"$'\n'
		esac
		val=${val#\"}
		val=${val%\"*} # throw away everything after the 2nd double-quote mark
		test_keys="${test_keys%%"${key}|"*}${test_keys#*"${key}|"}" # remove current key from test_keys
	}

	add_unexp_entry()
	{
		unexp_keys="${unexp_keys}${key} "
		unexp_entries="${unexp_entries}${entry}"$'\n'
	}

	local def_config='' conf_format_old='' curr_config='' missing_entries='' unexp_keys='' unexp_entries='' legacy_entries='' \
		test_keys entry key val tab="$(printf '\t')"

	unset curr_config_format def_config_format luci_curr_config_format luci_def_config_format luci_unexp_keys luci_unexp_entries luci_missing_keys luci_missing_entries \
		luci_legacy_entries luci_bad_conf_format luci_conf_fixes

	[ -z "${1}" ] && { reg_failure "parse_config(): no file specified."; return 1; }

	[ ! -f "${1}" ] && { reg_failure "Config file '${1}' not found."; return 1; }

	# extract entries from default config
	def_config="$(print_def_config | sed "${sed_conf_san_exp}")"

	# extract keys from default config, convert to '|' separated list
	# 'dummy|' is needed to avoid errors in eval
	test_keys="dummy|$(print_def_config | sed "${sed_conf_san_exp};"'s/=.*//' | tr '\n' '|')"

	# read and sanitize current config
	curr_config="$(sed "${sed_conf_san_exp}" "${1}")" || { reg_failure "Failed to read the config file '${1}'."; return 1; }

	# get config versions
	curr_config_format="$(get_config_format "${1}")"
	luci_curr_config_format=${curr_config_format}
	def_config_format="$(print_def_config | get_config_format)"
	luci_def_config_format=${def_config_format}

	local IFS=$'\n'
	for entry in ${curr_config}
	do
		case ${entry} in
			*?=*) ;;
			*) { inval_e; return 1; } ;;
		esac
		key="${entry%%=*}"
		case "${key}" in *[!A-Za-z0-9_]*) inval_e; return 1; esac
		# check if the key is in the default keys list, assign value to var if so
		eval "case \"${key}\" in
				${test_keys%|})
					parse_entry || return 1
					${key}"='${val}'" ;;
				*) add_unexp_entry
			esac"
	done

	IFS="${default_IFS}"

	test_keys=${test_keys#dummy|}
	if [ -n "${test_keys}" ]
	then
		missing_entries="$(printf %s "${def_config}" | grep -E "^(${test_keys%|})=")"
		missing_keys="$(printf %s "${test_keys}" | tr '|' ' ')"
	fi

	if [ -n "${unexp_entries}" ]
	then
		echo
		reg_failure "Unexpected keys in config: '${unexp_keys% }'."
		print_msg "Corresponding config entries:"
		print_msg "${unexp_entries%$'\n'}"
		add_conf_fix "Remove unexpected entries from the config"
		luci_unexp_keys=${unexp_keys% }
		luci_unexp_entries=${unexp_entries%$'\n'}
	fi

	if [ -n "${missing_keys% }" ]
	then
		echo
		reg_failure "Missing keys in config: '${missing_keys% }'."
		print_msg "Corresponding default config entries:"
		print_msg "${missing_entries}"
		add_conf_fix "Re-add missing config entries with default values"
		luci_missing_keys=${missing_keys% }
		luci_missing_entries=${missing_entries}
	fi

	if [ -n "${legacy_entries}" ]
	then
		echo
		reg_failure "Detected config entries in legacy format (missing double-quotes)."
		print_msg "The following config entries must be converted to the new config format:"
		print_msg "${legacy_entries%$'\n'}"
		add_conf_fix "Convert legacy config entries to the new format"
		luci_legacy_entries=${legacy_entries%$'\n'}
	fi

	case "${curr_config_format}" in *[!0-9]*|'')
		echo
		log_msg -warn "Config format version is unknown or invalid."
		conf_format_old=1
		add_conf_fix "Update config format version"
	esac

	if [ -z "${conf_format_old}" ] && [ "${curr_config_format}" -lt "${def_config_format}" ]
	then
		echo
		log_msg -warn "Current config format version '${curr_config_format}' is older than default config version '${def_config_format}'."
		add_conf_fix "Update config format version"
		luci_bad_conf_format=1
	fi

	conf_fixes="${conf_fixes%$'\n'}"
	luci_conf_fixes="${conf_fixes}"

	[ -n "${conf_fixes}" ] && return 2
	:
}

# shellcheck disable=SC2120
# 1 - (optional) '-f' to force fixing the config if it has issues
load_config()
{
	local conf_fixes='' fixed_config='' missing_keys='' key val line fix cnt \
		tip_msg="Fix your config file '${config_file}' or generate default config using 'service adblock-lean gen_config'."

	# validate config and assign to variables
	parse_config "${config_file}"

	case ${?} in
		0) return 0 ;;
		1) log_msg "${tip_msg}"; return 1 ;;
		2)
	esac

	[ "${msgs_dest}" != "/dev/tty" ] && [ "${1}" != '-f' ] && { log_msg "${tip_msg}"; return 1; }

	[ -z "${conf_fixes}" ] && { reg_failure "Failed to parse config."; return 1; }

	if [ "${msgs_dest}" = "/dev/tty" ] && [ "${1}" != '-f' ]
	then
		echo
		print_msg "${blue}Perform following automatic changes?${n_c}"
		cnt=0
		local IFS=$'\n'
		for fix in ${conf_fixes}
		do
			[ -z "${fix}" ] && continue
			cnt=$((cnt+1))
			print_msg "${cnt}. ${fix}"
		done
		IFS="${default_IFS}"
		pick_opt "y|n" || return 1
		[ "${REPLY}" = n ] && { log_msg "${tip_msg}"; return 1; }
	fi

	fix_config "${missing_keys}" || { report_failure "Failed to fix the config."; log_msg "${tip_msg}"; return 1; }

	:
}

# 1 - missing keys (whitespace-separated)
fix_config()
{
	local missing_keys="${1}"

	# recreate config from default while replacing values with values from the existing config
	fixed_config="$(
		IFS=$'\n'
		print_def_config | while read -r line
		do
			case ${line} in
				\#*|'') printf '%s\n' "${line}"; continue ;;
				*=*)
					key=${line%%=*}
					case " ${missing_keys} " in
						*" ${key} "*) printf '%s\n' "${line}"; continue ;;
						*)
							eval "val=\"\${${key}}\""
							printf '%s\n' "${key}=\"${val}\""
							continue
					esac
			esac
		done
	)"

	local old_config_f="/tmp/adblock-lean_config.old"
	if ! cp "${config_file}" "${old_config_f}"
	then
		reg_failure "Failed to save old config file as ${old_config_f}."
		[ "${msgs_dest}" != "/dev/tty" ] && return 1
		log_msg "Proceed with suggested config changes?"
		pick_opt "y|n" || return 1
		[ "${REPLY}" = n ] && return 1
	else
		log_msg "Old config file was saved as ${old_config_f}."
	fi

	write_config "${fixed_config}" || return 1

	:
}

# Writes config to temp file, validates it, moves it to permanent storage
# 1 - new config file contents
write_config()
{
	local tmp_config="${abl_dir}/write-config.tmp" missing_keys conf_fixes

	[ -z "${1}" ] && { reg_failure "write_config(): no config passed."; return 1; }

	try_mkdir -p "${abl_dir}" || return 1
	printf '%s\n' "${1}" > "${tmp_config}" || { reg_failure "Failed to write to file '${tmp_config}'."; return 1; }
	parse_config "${tmp_config}" ||
		{ rm -f "${tmp_config}"; reg_failure "Failed to validate the new config."; return 1; }

	echo
	log_msg "Saving new config file to '${config_file}'."
	try_mkdir -p "${PREFIX}" || return 1
	try_mv "${tmp_config}" "${config_file}" && return 0
	rm -f "${tmp_config}"
	return 1
}

# return codes:
# 0 - running
# 1,2 - (reserved)
# 3 - paused
# 4 - stopped
get_abl_run_state()
{
	local f
	for f in "${dnsmasq_tmp_d}/.blocklist.gz" "${dnsmasq_tmp_d}/blocklist"
	do
		[ -f "${f}" ] && return 0
	done

	[ -f "${abl_dir}/prev_blocklist.gz" ] && return 3
	return 4
}

clean_dnsmasq_dir()
{
	rm -f "${dnsmasq_tmp_d}"/.blocklist.gz "${dnsmasq_tmp_d}"/blocklist "${dnsmasq_tmp_d}"/conf-script "${dnsmasq_tmp_d}"/.extract_blocklist
}

# exit with code ${1}
# if function 'abl_luci_exit' is defined, execute it before exit
cleanup_and_exit()
{
	trap - INT TERM EXIT
	[ -n "${cleanup_req}" ] && rm -rf "${abl_dir}"
	[ -n "${lock_req}" ] && rm_lock
	local recent_log=
	[ -n "${log_file}" ] && [ -s "${log_file}" ] && read -rd '' recent_log < "${log_file}"
	luci_log="${recent_log}"
	if [ -z "${luci_sourced}" ] && [ -n "${failure_msg}" ] && [ -n "${custom_scr_sourced}" ] && command -v report_failure 1>/dev/null
	then
		[ -n "${recent_log}" ] && failure_msg="${failure_msg}"$'\n'$'\n'"Session log:"$'\n'"${recent_log}"
		report_failure "${failure_msg}"
	fi
	[ -n "${luci_sourced}" ] && abl_luci_exit "${1}"
	exit "${1}"
}

reg_failure()
{
	log_msg -err "${1}"
	failure_msg="${failure_msg}${1}"$'\n'
	luci_errors="${failure_msg}"
}

log_success()
{
	log_msg "${1}"
	success_msg="${1}"
	local recent_log=
	[ -n "${log_file}" ] && [ -s "${log_file}" ] && read -rd '' recent_log < "${log_file}"
	[ -n "${recent_log}" ] && success_msg="${success_msg}"$'\n'$'\n'"Session log:"$'\n'"${recent_log}"
	if [ -n "${custom_scr_sourced}" ] && command -v report_success 1>/dev/null
	then
		report_success "${1}"
	fi
}

try_export_existing_blocklist()
{
	export_existing_blocklist
	case ${?} in
		1) reg_failure "Failed to export the blocklist."; return 1 ;;
		2) return 2
	esac
	:	
}

check_blocklist_compression_support()
{
	if ! dnsmasq --help | grep -qe "--conf-script"
	then
		echo
		log_msg "Note: The version of dnsmasq installed on this system does not support blocklist compression."
		log_msg "Blocklist compression support in dnsmasq can be verified by checking the output of: dnsmasq --help | grep -e \"--conf-script\""
		log_msg "To use dnsmasq compression (which saves memory), upgrade OpenWrt and/or dnsmasq to a newer version that supports blocklist compression."
		return 1
	fi

	addnmount_str=$(uci get dhcp.@dnsmasq[0].addnmount 2> /dev/null)

	for addnmount_path in ${addnmount_str}
	do
		printf "%s" "$addnmount_path" | grep -qE "^/bin(/*|/busybox)?$" && return 0
	done

	reg_failure "No appropriate 'addnmount' entry in /etc/config/dhcp was identified."
	log_msg "This is leveraged to give dnsmasq access to busybox gunzip to extract compressed blocklist."
	log_msg "Add: \"list addnmount '/bin/busybox'\" to /etc/config/dhcp at the end of the dnsmasq section."
	log_msg "Or simply run this command: uci add_list dhcp.@dnsmasq[0].addnmount='/bin/busybox' && uci commit"
	log_msg "Either edit /etc/config/dhcp as described above or disable blocklist compression in config."
	return 1
}

cleanup_dl_status_files()
{
	rm -f "${abl_dir}/rogue_element" "${abl_dir}/dnsmasq_err" "${abl_dir}/uclient-fetch_err"
}

# 1 - list id
# 2 - list type (allowlist or blocklist)
# 3 - list origin (local or downloaded)
# 4 - local list path (for local lists) or URL (for downloaded lists)
#
# return codes:
# 0 - Success
# 1 - General error (stop processing)
# 2 - Bad List (retry doesn't make sense)
# 3 - Download Failure (retry makes sense)
process_list_part()
{
	local list_id="${1}" list_type="${2}" list_origin="${3}" list_path="${4}" me="process_list_part"
	local dest_file="${abl_dir}/${list_type}.${list_id}" compress_part='' \
		min_list_part_line_count='' list_part_size_B='' list_part_size_KB=''
	local sed_rogue_expr='(\*|[[:alnum:]_-]+)([.][[:alnum:]_-]+)+' sed_conv_expr=''

	[ -z "${list_id}" ] || [ -z "${list_origin}" ] || [ -z "${list_path}" ] && { reg_failure "${me}: Missing arguments."; return 1; }
	case ${list_type} in
		allowlist)
			sed_rogue_expr="^(server=/${sed_rogue_expr}/#$|$)"
			sed_conv_expr='s~.*~server=/&/#~'
			[ "${list_origin}" = local ] && dest_file="${abl_dir}/allowlist" ;;
		blocklist)
			sed_rogue_expr="^(local=/${sed_rogue_expr}/$|bogus-nxdomain=[0-9]+([.][0-9]+)+$|$)"
			case ${list_origin} in
				local) sed_conv_expr="s~.*~local=/&/~" ;;
				downloaded) sed_conv_expr="s/^address=/local=/"
			esac
			[ "$use_compression" = 1 ] && { dest_file="${dest_file}.gz"; compress_part=1; } ;;
		*) reg_failure "${me}: Missing or invalid list type '${list_type}'"; return 1
	esac

	eval "min_list_part_line_count=\"\${min_${list_type}_part_line_count}\""

	cleanup_dl_status_files

	# Download or cat the list
	case "${list_origin}" in
		downloaded) uclient-fetch "${list_path}" -O- --timeout=3 2> "${abl_dir}/uclient-fetch_err";;
		local) cat "${list_path}"
	esac |
	{ head -c "${max_file_part_size_KB}k"; cat 1>/dev/null; } |

	# Count bytes
	tee >(wc -c > "${abl_dir}/list_part_size_B") |

	# 1 Convert to lowercase; 2 Remove comment lines and trailing comments, remove whitespaces
	# 3 Convert blocklist to 'local=/[domain]/', allowlist to 'server=/[domain]/#'
	tr 'A-Z' 'a-z' | sed "${sed_san_expr}; ${sed_conv_expr}" |

	if [ "${list_type}" = blocklist ] && [ "${use_allowlist}" = 1 ]
	then
		# remove allowlist domains from blocklist
		${awk_cmd} -F'/' 'NR==FNR { sub(/^server=\//,""); sub(/\/#$/,""); allow[$0]; next } { n=split($2,arr,"."); addr = arr[n]; \
								for ( i=n-1; i>=1; i-- ) { addr = arr[i] "." addr; if ( addr in allow ) next } } 1' "${abl_dir}/allowlist" -
	else
		cat
	fi |
	tee >(wc -w > "${abl_dir}/list_part_line_count") |

	# check downloaded lists for rogue elements
	if [ "${list_origin}" = downloaded ]
	then
		tee >(sed -nE "\~${sed_rogue_expr}~d;p;:1 n;b1" > "${abl_dir}/rogue_element")
	else
		cat
	fi |

	# compress blocklist parts
	if [ -n "${compress_part}" ]
	then
		tee >(gzip > "${dest_file}")
	else
		tee "${dest_file}"
	fi |

	# check parts with dnsmasq --test
	{ dnsmasq --test -C - 2> "${abl_dir}/dnsmasq_err" && rm -f "${abl_dir}/dnsmasq_err"; cat 1>/dev/null; }

	read -r list_part_size_B _ < "${abl_dir}/list_part_size_B" 2>/dev/null
	list_part_size_KB=$(( (list_part_size_B + 0) / 1024 ))
	list_part_size_human="$(bytes2human "${list_part_size_B:-0}")"
	read -r list_part_line_count _ < "${abl_dir}/list_part_line_count" 2>/dev/null
	: "${list_part_line_count:=0}"

	rm -f "${abl_dir}/list_part_size_B" "${abl_dir}/list_part_line_count"

	if [ "${list_part_size_KB}" -ge "${max_file_part_size_KB}" ]
	then
		reg_failure "${list_origin} ${list_type} part size reached the maximum value set in config (${max_file_part_size_KB} KB)."
		log_msg "Consider either increasing this value in the config or removing the corresponding ${list_type} part path or URL from config."
		log_msg "Skipping ${list_type} part and continuing."
		rm -f "${dest_file}"
		return 2
	fi

	if [ "${list_origin}" = downloaded ] && ! grep -q "Download completed" "${abl_dir}/uclient-fetch_err"
	then
		rm -f "${dest_file}"
		reg_failure "Download of new ${list_type} file part from: ${list_path} failed."
		return 3
	fi

	if [ "${list_origin}" = downloaded ] && read -r rogue_element < "${abl_dir}/rogue_element"
	then
		rm -f "${dest_file}"
		log_msg -warn "Rogue element: '${rogue_element}' identified originating in ${list_type} file part from: ${list_path}."
		return 2
	fi
	rm -f "${abl_dir}/rogue_element"

	if [ -f "${abl_dir}/dnsmasq_err" ]
	then
		rm -f "${dest_file}"
		reg_failure "The dnsmasq --test on the ${list_type} part failed."
		log_msg "dnsmasq --test errors:"
		log_msg "$(head -n10 "${abl_dir}/dnsmasq_err")"
		rm -f "${abl_dir}/dnsmasq_err"
		return 2
	fi
	rm -f "${abl_dir}/dnsmasq_err"

	if [ "${list_origin}" = downloaded ] && [ "${list_part_line_count}" -lt "${min_list_part_line_count}" ]
	then
		rm -f "${dest_file}"
		reg_failure "Downloaded ${list_type} part line count: $(int2human ${list_part_line_count}) less than configured minimum: $(int2human ${min_list_part_line_count})."
		return 3
	fi

	cleanup_dl_status_files
	:
}

gen_list_parts()
{
	# 1 - list origin (local or downloaded)
	log_process_success()
	{
		local part=
		[ "${1}" = downloaded ] && part=" part"
		log_msg "Successfully processed ${1} ${list_type}${part} (source file size: ${list_part_size_human}, sanitized line count: $(int2human ${list_part_line_count}))."
	}

	handle_process_failure()
	{
		[ "${list_part_failed_action}" = "STOP" ] && { log_msg "list_part_failed_action is set to 'STOP', exiting."; return 1; }
		log_msg "Skipping file part and continuing."
		:
	}

	local list_type='' list_id list_line_count list_part_line_count and_compressing='' list_urls list_url local_list_path

	for list_type in allowlist blocklist
	do
		rm -f "${abl_dir}/${list_type}"*
		list_id=0 list_line_count=0 list_part_line_count=0
		and_compressing=
		[ ${list_type} = blocklist ] && [ "${use_compression}" = 1 ] && and_compressing=" and compressing"

		# Local list
		echo
		eval "local_list_path=\"\${local_${list_type}_path}\""
		if [ ! -f "${local_list_path}" ]
		then
			log_msg -blue "No local ${list_type} identified."
		elif [ ! -s "${local_list_path}" ]
		then
			log_msg -warn "Local ${list_type} file is empty."
		else
			echo
			log_msg -blue "Found local ${list_type}. Sanitizing${and_compressing}."
			reg_action -nolog "Sanitizing${and_compressing} the local ${list_type}." || return 1
			process_list_part "${list_id}" "${list_type}" "local" "${local_list_path}"
			case ${?} in
				0)
					log_process_success "local"
					list_line_count=$(( list_line_count + list_part_line_count )) ;;
				*)
					handle_process_failure || return 1
			esac
		fi

		# List parts download
		eval "list_urls=\"\${${list_type}_urls}\""
		if [ -z "${list_urls}" ]
		then
			[ "${list_type}" = blocklist ] && log_msg -yellow "NOTE: No URLs specified for blocklist download. Skipping download."
		else
			echo
			reg_action -blue "Starting ${list_type} part(s) download." || return 1
		fi

		for list_url in ${list_urls}
		do
			reg_action "Downloading, checking and sanitizing ${list_type} part from: ${list_url}." || return 1
			list_id=$((list_id+1))
			retry=0
			while :
			do
				retry=$((retry + 1))
				list_part_line_count=0
				process_list_part "${list_id}" "${list_type}" "downloaded" "${list_url}"
				case ${?} in
					0)
						if [ "${list_type}" = allowlist ]
						then
							cat "${abl_dir}/${list_type}.${list_id}" >> "${abl_dir}/allowlist" ||
								{ reg_failure "Failed to merge allowlist part."; return 1; }
							rm -f "${abl_dir}/${list_type}.${list_id}"
						fi
						log_process_success "downloaded"
						list_line_count=$(( list_line_count + list_part_line_count ))
						continue 2 ;;
					1) return 1 ;;
					2)
						handle_process_failure || return 1
						continue 2 ;;
					3) ;;
				esac

				if [ "${retry}" -ge "${max_download_retries}" ]
				then
					reg_failure "Three download attempts failed."
					handle_process_failure || return 1
					continue 2
				fi

				reg_action -blue "Sleeping for 5 seconds after failed download attempt." || return 1
				sleep 5
				continue
			done
		done

		if [ "${list_line_count}" = 0 ] || { [ "${list_type}" = allowlist ] && [ ! -f "${abl_dir}/allowlist" ]; }
		then
			case ${list_type} in
				blocklist) return 1 ;;
				allowlist)
					log_msg "Not using any allowlist for blocklist processing."
					use_allowlist=0
					continue
			esac
		fi

		if [ "${list_type}" = allowlist ]
		then
			echo
			log_msg -green "Successfully generated allowlist with $(int2human ${list_line_count}) lines."
			log_msg "Will remove any (sub)domain matches present in the allowlist from the blocklist and append corresponding server entries to the blocklist."
			use_allowlist=1
		else
			preprocessed_blocklist_line_count="${list_line_count}"
		fi
	done
	:
}

generate_and_process_blocklist_file()
{
	echo
	reg_action -blue "Sorting and merging the blocklist parts into a single blocklist file." || return 1

	local out_f="${abl_dir}/blocklist"
	[ -n "${final_compress}" ] && out_f="${out_f}.gz"
	{
		[ "${use_allowlist}" = 1 ] && cat "${abl_dir}/allowlist"
		rm -f "${abl_dir}/allowlist"

		local find_name="blocklist.[0-9]*" find_cmd="cat"
		[ "${use_compression}" = 1 ] && { find_name="blocklist.*.gz" find_cmd="gunzip -c"; }
		find "${abl_dir}" -name "${find_name}" -exec ${find_cmd} {} \; -exec rm -f {} \;
	} | sort -u |
	{ head -c "${max_blocklist_file_size_KB}k"; cat 1>/dev/null; } |
	{ tee >(wc -wc > "${abl_dir}/blocklist_stats"); printf '%s\n' "address=/adblocklean-test123.info/127.0.0.1"; } |

	if  [ -n "${final_compress}" ]
	then
		gzip
	else
		cat
	fi > "${out_f}" || { reg_failure "Failed to write to output file '${out_f}'."; return 1; }

	read -r good_line_count blocklist_file_size_B < "${abl_dir}/blocklist_stats" 2>/dev/null
	: "${good_line_count:=0}"

	blocklist_file_size_KB=$(( (blocklist_file_size_B + 0) / 1024 ))
	blocklist_file_size_human="$(bytes2human "${blocklist_file_size_B}")"

	if [ "${blocklist_file_size_KB}" -ge "${max_blocklist_file_size_KB}" ]
	then
		reg_failure "Blocklist file size reached the maximum value set in config ($(int2human "${max_blocklist_file_size_KB}") KB)."
		log_msg "Consider either increasing this value in the config or changing the blocklist URLs."
		return 1
	fi

	if [ "${good_line_count}" -lt "${min_good_line_count}" ]
	then
		reg_failure "Good line count: $(int2human "${good_line_count}") below the minimum value set in config ($(int2human "${min_good_line_count}"))."
		return 1
	fi

	log_msg "Processed blocklist uncompressed file size: ${blocklist_file_size_human}."

	:
}


# return codes:
# 0 - dnsmasq running
# 1 - dnsmasq not running or failed to detect dnsmasq directory
check_dnsmasq_instance()
{
	! pgrep -x /usr/sbin/dnsmasq &>/dev/null && { reg_failure "No running instance of dnsmasq detected."; return 1; }
	[ ! -d "${dnsmasq_tmp_d}" ] &&
		{ reg_failure "Directory '${dnsmasq_tmp_d}' does not exist. Failed to detect dnsmasq directory or dnsmasq is not running."; return 1; }
	:
}

# return values:
# 0 - dnsmasq is running, and all checks passed
# 1 - dnsmasq is not running
# 2 - dnsmasq is running, but one of the test domains failed to resolve
# 3 - dnsmasq is running, but one of the test domains resolved to 0.0.0.0
# 4 - dnsmasq is running, but the blocklist test domain failed to resolve (blocklist not loaded)
check_active_blocklist()
{
	echo
	reg_action -blue "Checking active blocklist." || return 1

	check_dnsmasq_instance || return 1

	nslookup "adblocklean-test123.info" 127.0.0.1 1>/dev/null 2>/dev/null ||
			{ reg_failure "Lookup of the blocklist test domain failed with new blocklist."; return 4; }

	for domain in google.com amazon.com microsoft.com
	do
		ns_res="$(nslookup "${domain}" 127.0.0.1 2>/dev/null)" ||
			{ reg_failure "Lookup of '${domain}' failed with new blocklist."; return 2; }

		printf %s "${ns_res}" | grep -A1 ^Name | grep -q '^Address: *0\.0\.0\.0$' &&
			{ reg_failure "Lookup of '${domain}' resulted in 0.0.0.0 with new blocklist."; return 3; }
	done

	:
}

restart_dnsmasq()
{
	[ "$action" = "start" ] && echo
	reg_action -blue "Restarting dnsmasq." || return 1

	/etc/init.d/dnsmasq restart &> /dev/null || 
		{ reg_failure "Failed to restart dnsmasq."; return 1; }
	
	reg_action "Waiting for dnsmasq initialization." || return 1
	local dnsmasq_ok=
	for i in $(seq 1 60)
	do
		nslookup localhost 127.0.0.1 &> /dev/null && { dnsmasq_ok=1; break; }
		sleep 1;
	done

	[ -z "$dnsmasq_ok" ] && { reg_failure "dnsmasq initialization failed."; return 1; }

	log_msg -green "Restart of dnsmasq completed."
	:
}

# return codes:
# 0 - success
# 1 - failure
# 2 - blocklist file not found (nothing to export)
export_existing_blocklist()
{
	reg_export()
	{
		reg_action -blue "Creating ${1} backup of existing blocklist." || return 1
	}

	local src src_d="${dnsmasq_tmp_d}" dest="${abl_dir}/prev_blocklist"
	echo
	if [ -f "${src_d}/.blocklist.gz" ]
	then
		case ${use_compression} in
			1)
				src="${src_d}/.blocklist.gz" dest="${dest}.gz"
				reg_export compressed || return 1 ;;
			*)
				reg_export uncompressed || return 1
				try_gunzip "${src_d}/.blocklist.gz" || { rm -f "${src_d}/.blocklist.gz"; return 1; }
				src="${src_d}/.blocklist"
		esac
	elif [ -f "${src_d}/blocklist" ]
	then
		if [ "${use_compression}" = 1 ]
		then
			reg_export compressed || return 1
			try_mv "${src_d}/blocklist" "${src_d}/.blocklist" || return 1
			try_gzip "${src_d}/.blocklist" || return 1
			src="${src_d}/.blocklist.gz" dest="${dest}.gz"
		else
			reg_export uncompressed || return 1
			src="${src_d}/blocklist"
		fi
	else
		log_msg "No existing compressed or uncompressed blocklist identified."
		return 2
	fi
	try_mv "${src}" "${dest}" || return 1
	:
}

restore_saved_blocklist()
{
	local mv_src="${abl_dir}/prev_blocklist" mv_dest="${abl_dir}/blocklist"
	echo
	reg_action -blue "Restoring saved blocklist file." || return 1
	if [ -f "${mv_src}.gz" ]
	then
		try_mv "${mv_src}.gz" "${mv_dest}.gz" || return 1
		if [ -z "${final_compress}" ]
		then
			try_gunzip "${mv_dest}.gz" || return 1
		fi
	elif [ -f "${mv_src}" ]
	then
		try_mv "${mv_src}" "${mv_dest}" || return 1
		if [ -n "${final_compress}" ]
		then
			try_gzip -f "${mv_dest}" ||return 1
		fi
	else
		reg_failure "No previous blocklist file found."
		return 1
	fi
	import_blocklist_file || { reg_failure "Failed to import the blocklist file."; return 1; }
	:
}

import_blocklist_file()
{
	local src src_compressed='' src_file="${abl_dir}/blocklist" dest_file="${dnsmasq_tmp_d}/blocklist"
	[ -n "${final_compress}" ] && dest_file="${dnsmasq_tmp_d}/.blocklist.gz"
	for src in "${src_file}" "${src_file}.gz"
	do
		case "${src}" in *.gz) src_compressed=1; esac
		[ -f "${src}" ] && { src_file="${src}"; break; }
	done || { reg_failure "Failed to find file to import."; return 1; }

	clean_dnsmasq_dir

	if [ -n "${src_compressed}" ] && [ -z "${final_compress}" ]
	then
		try_gunzip "${src_file}" || return 1
		src_file="${src_file%.gz}"
	elif [ -z "${src_compressed}" ] && [ -n "${final_compress}" ]
	then
		try_gzip "${src_file}" || return 1
		src_file="${src_file}.gz"
	fi

	try_mv "${src_file}" "${dest_file}" || return 1
	imported_blocklist_file_size_human=$(get_file_size_human "${dest_file}")

	if [ -n "${final_compress}" ]
	then
		printf "conf-script=\"busybox sh ${dnsmasq_tmp_d}/.extract_blocklist\"\n" > "${dnsmasq_tmp_d}"/conf-script &&
		printf "busybox gunzip -c ${dnsmasq_tmp_d}/.blocklist.gz\nexit 0\n" > "${dnsmasq_tmp_d}"/.extract_blocklist ||
			{ reg_failure "Failed to create conf-script for dnsmasq."; return 1; }
	fi

	:
}

# return values:
# 0 - up-to-date
# 1 - not up-to-date
# 2 - update check failed
check_for_updates()
{
	echo
	rm -f "${abl_dir}/uclient-fetch_err"
	sha256sum_adblock_lean_local=$(sha256sum /etc/init.d/adblock-lean | sed -E 's/[ \t]+.*$//')
	sha256sum_adblock_lean_remote=$(uclient-fetch https://mirror.ghproxy.com/https://raw.githubusercontent.com/lynxthecat/adblock-lean/master/adblock-lean -O - \
		2> "${abl_dir}/uclient-fetch_err" |
		tee >(cat > "${abl_dir}/remote_abl"; . "${abl_dir}/remote_abl" 1>/dev/null 2>/dev/null && print_def_config |
			get_config_format > "${abl_dir}/upd_config_format") |
		sha256sum | sed -E 's/[ \t]+.*$//')

	local bad_dl='' update_check_result=''
	read -r luci_upd_config_format _ < "${abl_dir}/upd_config_format" 2>/dev/null
	rm -f "${abl_dir}/remote_abl" "${abl_dir}/upd_config_format"

	# safeguard against receiving empty string or empty string+newline
	case "${sha256sum_adblock_lean_remote}" in *9805daca546b|*991b7852b855) bad_dl=1; esac

	if [ -z "${bad_dl}" ] && grep -q "Download completed" "${abl_dir}/uclient-fetch_err"
	then
		if [ "${sha256sum_adblock_lean_local}" = "${sha256sum_adblock_lean_remote}" ]
		then
			log_msg "The locally installed adblock-lean is the latest version."
			update_check_result=0
		else
			log_msg -yellow "The locally installed adblock-lean seems to be outdated."
			log_msg "Consider running: 'service adblock-lean update' to update it to the latest version."
			update_check_result=1
		fi
	else
		reg_failure "Unable to download latest version of adblock-lean to check for any updates."
		update_check_result=2
	fi
	rm -f "${abl_dir}/uclient-fetch_err"

	return ${update_check_result}
}

# updates the pid file with a new action
# 1 - new action
update_pid_action() {
	check_lock
	case ${?} in
		3) ;;
		1) return 1 ;;
		2) reg_failure "update_pid_action(): pid file '${pid_file}' has unexpected pid '${_pid}'."; return 1 ;;
		0) reg_failure "update_pid_action(): pid file '${pid_file}' not found."; return 1
	esac
	mk_lock -f "${1}"
	return ${?}
}

# args:
# 1 - (optional) -f to skip check for existing lock
# 1/2 - action to write to the pid file
#
# return codes:
# 0 - success
# 1 - error
# 254 - lock file already exists
mk_lock()
{
	local me="mk_lock"
	if [ "${1}" != '-f' ]
	then
		check_lock
		case ${?} in
			1) return 1 ;;
			2)
				report_pid_action
				log_msg "Refusing to open another instance."
				return 254
		esac
	else
		shift
	fi

	[ -z "${1%.}" ] && { reg_failure "${me}: pid action is unspecified."; return 1; }
	[ -z "${pid_file}" ] && { reg_failure "${me}: \${pid_file} variable is unset."; return 1; }

	try_mkdir "${abl_pid_dir}" || return 1
	printf '%s\n' "${$} ${1%.}" > "${pid_file}" || { reg_failure "${me}: Failed to write to pid file '${pid_file}'."; return 1; }
	:
}

rm_lock()
{
	if [ -f "${pid_file}" ]
	then
		rm -f "${pid_file}" || { reg_failure "Failed to delete the pid file '${pid_file}'."; return 1; }
	fi
	:
}

# return codes:
# 0 - no lock
# 1 - error
# 2 - lock file exists and belongs to another PID
# 3 - lock file belongs to current PID
check_lock()
{
	unset _pid pid_action
	[ -z "${pid_file}" ] && { reg_failure "\${pid_file} variable is unset."; return 1; }
	[ ! -f "${pid_file}" ] && return 0
	if read -r _pid pid_action < "${pid_file}"
	then
		case "${_pid}" in
			${$}) return 3 ;;
			*[!0-9]*) reg_failure "pid file '${pid_file}' contains unexpected string."; return 1 ;;
			*) kill -0 "${_pid}" 2>/dev/null && return 2
		esac
	else
		reg_failure "Failed to read the pid file '${pid_file}'."
		return 1
	fi

	log_msg -warn "Detected stale pid file '${pid_file}'. Removing."
	rm_lock || return 1
	:
}

# kills any running adblock-lean instances
kill_abl_pids()
{
	local _killed _p _pid child_pid IFS=$'\n' k_attempt=0
	while :
	do
		k_attempt=$((k_attempt+1))
		_killed=
		for _p in $(pgrep -fa "(/etc/rc.common /etc/(rc.d/S${START}adblock-lean|init.d/adblock-lean)|luci.adblock-lean)")
		do
			_pid="${_p%% *}"
			case ${_pid} in "${$}"|*[!0-9]*) continue; esac
			kill "${_pid}" 2>/dev/null
			for child_pid in $(pgrep -P "${_pid}")
			do
				kill "${child_pid}" 2>/dev/null
			done
			_killed=1
		done
		[ -z "${_killed}" ] || [ ${k_attempt} -gt 10 ] && break
		sleep 1
	done
	:
}

# (optional) -nolog
# (optional) -[color]
# other args - action
reg_action()
{
	local msg='' nolog='' color=''
	for _arg in "$@"
	do
		case "${_arg}" in
			-nolog) nolog=1 ;;
			-blue|-red|-green|-purple|-yellow) color="${_arg}" ;;
			*) msg="${msg}${_arg} "
		esac
	done

	[ -z "${nolog}" ] && log_msg "${color}" "${msg% }"
	if [ -n "${lock_req}" ]
	then
		update_pid_action "${msg% }" || return 1
	fi
	:
}

report_pid_action()
{
	local reported_pid="unknown PID"
	[ -n "${_pid}" ] && reported_pid="PID ${_pid}"
	: "${pid_action:="unknown action"}"
	print_msg "adblock-lean (${reported_pid}) is performing action '${pid_action}'."
	luci_pid_action=${pid_action}
	:
}

init_command()
{
	action="${1}"
	pid_file="${abl_pid_dir}/adblock-lean.pid"
	unset lock_req kill_req cleanup_req failure_msg luci_errors init_action_msg

	# detect if sourced from external RPC script for luci, depends on abl_luci_exit() being defined
	luci_sourced=
	command -v "abl_luci_exit" 1>/dev/null && luci_sourced=1

	trap 'cleanup_and_exit 1' INT TERM
	trap 'cleanup_and_exit ${?}' EXIT

	# set requirements
	case ${action} in
		help|status|gen_stats|print_log|enabled|enable|disable|'') ;;
		gen_config|pause) lock_req=1 ;;
		boot|start|update|resume) cleanup_req=1 lock_req=1 ;;
		stop)
			init_action_msg="Stopping adblock-lean."
			reg_action -purple "${init_action_msg}" || exit 1
			cleanup_req=1 kill_req=1 lock_req=1 ;;
		reload|restart) reg_action -purple "Restarting adblock-lean." || exit 1 ;;
		*) reg_failure "Invalid action '${action}'."; exit 1
	esac

	# kill pids if needed
	if [ -n "${kill_req}" ]
	then
		kill_abl_pids
		check_lock
		case ${?} in
			1) exit 1 ;;
			2)
				reg_failure "Failed to kill running adblock-lean processes."
				unset lock_req cleanup_req
				exit 1
		esac
	fi

	# set dnsmasq_tmp_d
	case ${action} in boot|start|stop|status|pause|resume|update)
		dnsmasq_tmp_d="$(uci get dhcp.@dnsmasq[0].confdir 2>/dev/null)"
		: "${dnsmasq_tmp_d:=/tmp/dnsmasq.d}"
	esac

	# register lock status at init
	check_lock
	local init_lock_status=${?}

	# make lock if needed
	if [ -n "${lock_req}" ]
	then
		mk_lock "${action}" || { unset lock_req cleanup_req; exit ${?}; }
	fi

	# init session log if we have the lock
	log_file=
	case ${init_lock_status} in 0|3)
		case ${action} in
			start|boot|stop|restart|reload|pause|resume) log_file="${session_log_file}" ;;
			update) log_file="${update_log_file}"
		esac
	esac

	# if creating new session, rotate the old session log file
	[ "${init_lock_status}" = 0 ] && [ -n "${log_file}" ] && [ -f "${log_file}" ] && mv "${log_file}" "${log_file}.0"

	[ -n "${init_action_msg}" ] && write_log_file "${init_action_msg}" "info"

	# create work dir, check dnsmasq, load config, source custom script
	case ${action} in
		status) try_mkdir -p "${abl_dir}" || exit 1 ;;
		start|boot|pause|resume|update)
			check_dnsmasq_instance || exit 1
			try_mkdir -p "${abl_dir}" || exit 1
			load_config || { reg_failure "Failed to load config."; exit 1; }
			if [ -n "${custom_script}" ]
			then
				custom_scr_sourced=
				[ -f "${custom_script}" ] && . "${custom_script}" && custom_scr_sourced=1
				[ -z "${custom_scr_sourced}" ] && reg_failure "Custom script '${custom_script}' doesn't exist or it returned error."
			fi
	esac

	:
}

### MAIN COMMAND FUNCTIONS

print_log()
{
	[ ! -s "${session_log_file}" ] && { log_msg -err "Session log file '${session_log_file}' doesn't exist or is empty."; exit 1; }
	echo "Most recent session log:"
	cat "${session_log_file}"
	:
}

# 1 - (optional) '-noexit' to return to the calling function
gen_stats()
{
	echo
	reg_action -blue "Generating dnsmasq stats." || exit 1
	local dnsmasq_pid
	dnsmasq_pid="$(pidof /usr/sbin/dnsmasq)" || { reg_failure "Failed to detect dnsmasq PID or dnsmasq is not running."; exit 1; }
	kill -USR1 "${dnsmasq_pid}"
	print_msg "dnsmasq stats available for reading using 'logread'."
	[ "${1}" != '-noexit' ] && exit 0
}

gen_config()
{
	init_command gen_config || exit 1
	reg_action -purple "Generating new default config for adblock-lean." || exit 1
	if [ "${msgs_dest}" = "/dev/tty" ] && [ -f "${config_file}" ]
	then
		print_msg "This will overwrite existing config with default one. Proceed?"
		pick_opt "y|n" || exit 1
		[ "${REPLY}" = n ] && exit 1
	fi
	write_config "$(print_def_config)" || exit 1
	check_blocklist_compression_support
	:
}

boot()
{
	init_command boot || exit 1
	reg_action -purple "Sleeping for ${boot_start_delay_s} seconds." || exit 1
	sleep "${boot_start_delay_s}"
	start "$@"
}

start()
{
	init_command start || exit 1
	log_msg -purple "Started adblock-lean."
	echo

	if type gawk &> /dev/null
	then
		log_msg "gawk detected so using gawk for fast (sub)domain match removal."
		awk_cmd="gawk"
	else
		log_msg "gawk not detected so using awk for the (sub)domain match removal."
		log_msg "Consider installing the gawk package 'opkg install gawk' for faster (sub)domain match removal."
		awk_cmd="awk"
	fi

	if sort --version 2>/dev/null | grep -qe coreutils
	then
		log_msg "coreutils-sort detected so sort will be fast."
	else
		log_msg "coreutils-sort not detected so sort will be a little slower."
		log_msg "Consider installing the coreutils-sort package (opkg install coreutils-sort) for faster sort."
	fi

	final_compress=
	[ "${use_compression}" = 1 ] && check_blocklist_compression_support && final_compress=1

	if [ "${RANDOM_DELAY}" = "1" ]
	then
		random_delay_mins=$(($(hexdump -n 1 -e '"%u"' </dev/urandom)%60))
		reg_action -purple "Delaying adblock-lean by: ${random_delay_mins} minutes (thundering herd prevention)." || exit 1
		sleep "${random_delay_mins}m"
	fi

	try_export_existing_blocklist
	[ ${?} = 1 ] && exit 1

	if [ "${initial_dnsmasq_restart}" = 1 ]
	then
		restart_dnsmasq || exit 1
	fi

	initial_uptime_ms=$(get_uptime_ms)

	if ! gen_list_parts
	then
		reg_failure "Failed to generate preprocessed blocklist file with at least one line."
		restore_saved_blocklist
		exit 1
	fi

	echo
	log_msg -green "Successfully generated preprocessed blocklist file with $(int2human ${preprocessed_blocklist_line_count}) lines."

	if ! generate_and_process_blocklist_file
	then
		reg_failure "New blocklist file check failed."
		restore_saved_blocklist
		exit 1
	fi

	log_msg -green "New blocklist file check passed."

	if ! import_blocklist_file
	then
		reg_failure "Failed to import new blocklist file."
		restore_saved_blocklist
		exit 1
	fi

	compressed=
	[ -n "${final_compress}" ] && compressed=" compressed"
	log_msg "Successfully imported new${compressed} blocklist file for use by dnsmasq with size: ${imported_blocklist_file_size_human}."

	restart_dnsmasq || exit 1

	elapsed_time_str=$(get_elapsed_time_str)
	echo
	log_msg "Processing time for blocklist generation and import: ${elapsed_time_str}."

	if ! check_active_blocklist
	then
		reg_failure "Active blocklist check failed with new blocklist file."

		if ! restore_saved_blocklist
		then
			reg_failure "Failed to restore saved blocklist."
			stop 1
		fi

		if ! restart_dnsmasq
		then
			log_msg "Stopping adblock-lean."
			stop 1
		fi

		if ! check_active_blocklist
		then
			reg_failure "Active blocklist check failed with previous blocklist file."
			stop 1
		fi

		log_msg -green "Previous blocklist restored and dnsmasq check passed."
		exit 1
	fi

	log_msg -green "Active blocklist check passed with new blocklist file."
	log_success "New blocklist installed with good line count: $(int2human "${good_line_count}")."
	rm -f "${abl_dir}/prev_blocklist.gz"

	check_for_updates
	exit 0
}

# 1 - (optional) exit code
# 1/2 - (optional) '-noexit' to return to the calling function
stop()
{
	local stop_rc=0 noexit=
	for _arg in "$@"
	do
		case "${_arg}" in
			"-noexit") noexit=1 ;;
			*[!0-9]*|'') ;;
			*) stop_rc="${_arg}"
		esac
	done
	msg="${msg% }"

	init_command stop || exit 1
	reg_action "Removing any adblock-lean blocklist files in ${dnsmasq_tmp_d}/ and restarting dnsmasq." || exit 1
	clean_dnsmasq_dir
	/etc/init.d/dnsmasq restart &> /dev/null
	log_msg -purple "Stopped adblock-lean."
	[ -n "$noexit" ] && return "${stop_rc}"
	exit "${stop_rc}"
}

restart()
{
	init_command restart || exit 1
	stop -noexit || exit 1
	start
}

reload()
{
	restart
}

# return codes:
# 0 - adblock-lean blocklist is loaded
# 1 - error
# 2 - adblock-lean is performing an action
# 3 - adblock-lean is paused
# 4 - adblock-lean is stopped
status()
{
	init_command status || exit 1
	check_lock
	case ${?} in
		1) exit 1 ;;
		2)
			report_pid_action
			exit 2
	esac

	get_abl_run_state
	case ${?} in
		0) ;;
		3) log_msg -purple "adblock-lean is currently paused."; exit 3 ;;
		4) log_msg -purple "adblock-lean is stopped."; exit 4;
	esac
	check_active_blocklist
	local dnsmasq_status=${?}
	luci_dnsmasq_status=${dnsmasq_status}
	if [ ${dnsmasq_status} = 0 ]
	then
		if [ -f "${dnsmasq_tmp_d}"/.blocklist.gz ]
		then
			good_line_count=$(gunzip -c "${dnsmasq_tmp_d}"/.blocklist.gz | wc -w)
		elif [ -f "${dnsmasq_tmp_d}"/blocklist ]
		then
			good_line_count=$(wc -w < "${dnsmasq_tmp_d}/blocklist")
		fi
		: "${good_line_count:=0}"
		[ ${good_line_count} -gt 0 ] && : $((good_line_count--)) # to account for added blocklist test entry
		luci_good_line_count=${good_line_count}
		log_msg "The dnsmasq check passed and the presently installed blocklist has good line count: $(int2human ${good_line_count})."
		log_msg -green "adblock-lean is active."
		gen_stats -noexit
	else
		reg_failure "The dnsmasq check failed with existing blocklist file."
		log_msg "Consider a full reset by running: 'service adblock-lean restart'."
	fi
	check_for_updates
	luci_update_status=${?}

	[ ${dnsmasq_status} = 0 ] && exit 0
	exit 1
}

pause()
{
	init_command pause || exit 1
	get_abl_run_state
	case ${?} in
		0) ;;
		3) log_msg -err "adblock-lean is already paused."; exit 1 ;;
		4) log_msg -err "adblock-lean is currently stopped."; exit 1;
	esac
	reg_action -purple "Pausing adblock-lean." || exit 1
	try_export_existing_blocklist || exit 1
	restart_dnsmasq || exit 1
	log_msg -purple "adblock-lean is now paused."
	exit 0
}

resume()
{
	init_command resume || exit 1
	get_abl_run_state
	case ${?} in
		0) log_msg -err "adblock-lean is already running."; exit 1 ;;
		3) ;;
		4) log_msg -err "adblock-lean is currently stopped, not paused. Can not resume."; exit 1;
	esac

	reg_action -purple "Resuming adblock-lean." || exit 1
	restore_saved_blocklist || 
		{ reg_failure "Failed to restore saved blocklist. Stopping adblock-lean."; stop 1; }
	restart_dnsmasq || exit 1
	log_msg -purple "adblock-lean is now resumed."
	exit 0
}

# 1 - (optional) '-no-check-config' to skip checking config compatibility with the newer version
update()
{
	failsafe_log()
	{
		printf '%s\n' "${1}" > "${msgs_dest:-/dev/tty}"
		logger -t adblock-lean "${1}"
	}

	init_command update || exit 1
	reg_action -purple "Obtaining latest version of adblock-lean." || exit 1
	uclient-fetch https://mirror.ghproxy.com/https://raw.githubusercontent.com/lynxthecat/adblock-lean/master/adblock-lean \
		-O "${abl_dir}/adblock-lean.latest" 1> /dev/null 2> "${abl_dir}/uclient-fetch_err"
	if ! grep -q "Download completed" "${abl_dir}/uclient-fetch_err"
	then
		reg_failure "Unable to download latest version of adblock-lean."
		rm -f "${abl_dir}/adblock-lean.latest" "${abl_dir}/uclient-fetch_err"
		exit 1
	fi

	if [ "${1}" != '-no-check-config' ]
	then
		(
			prev_config_format="${curr_config_format}"
			. "${abl_dir}/adblock-lean.latest" || exit 1
			command -v print_def_config && command -v get_config_format && upd_config_format="$(print_def_config | get_config_format)"
			if [ -n "${upd_config_format}" ] && [ -n "${prev_config_format}" ] && [ "${upd_config_format}" != "${prev_config_format}" ]
			then
				failsafe_log "NOTE: config format has changed."
				if command -v load_config
				then
					load_config
				else
					failsafe_log "Please run 'service adblock-lean start' to initialize the new config."
				fi
			fi
			:
		) 1>/dev/null ||
		{
			report_failure "Failed to source the downloaded file. Canceling the update."
			rm -f "${abl_dir}/adblock-lean.latest"
			exit 1
		}
	fi

	try_mv "${abl_dir}/adblock-lean.latest" /etc/init.d/adblock-lean || exit 1
	chmod +x /etc/init.d/adblock-lean
	/etc/init.d/adblock-lean enable
	log_msg -green "adblock-lean has been updated to the latest version."

	rm -f "${abl_dir}/adblock-lean.latest" "${abl_dir}/uclient-fetch_err"
	exit 0
}

set_colors
sed_san_expr='s/#.*$//; s/^[ \t]*//; s/[ \t]*$//; /^$/d'
sed_conf_san_exp='/^[ \t]*#.*$/d; s/^[ \t]*//; s/[ \t]*$//; /^$/d'

:
